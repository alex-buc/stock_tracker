{"ast":null,"code":"/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';\nimport { NotifierAnimationService } from './../services/notifier-animation.service';\nimport { NotifierNotification } from './../models/notifier-notification.model';\nimport { NotifierService } from './../services/notifier.service';\nimport { NotifierTimerService } from './../services/notifier-timer.service';\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from './../services/notifier.service';\nimport * as ɵngcc2 from './../services/notifier-timer.service';\nimport * as ɵngcc3 from './../services/notifier-animation.service';\nimport * as ɵngcc4 from '@angular/common';\n\nfunction NotifierNotificationComponent_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 2);\n    ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_button_2_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.onClickDismiss();\n    });\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(1, \"svg\", 3);\n    ɵngcc0.ɵɵelement(2, \"path\", 4);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n}\n\nexport let NotifierNotificationComponent = /*#__PURE__*/(() => {\n  class NotifierNotificationComponent {\n    /**\n     * Constructor\n     *\n     * @param {?} elementRef               Reference to the component's element\n     * @param {?} renderer                 Angular renderer\n     * @param {?} notifierService          Notifier service\n     * @param {?} notifierTimerService     Notifier timer service\n     * @param {?} notifierAnimationService Notifier animation service\n     */\n    constructor(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n      this.config = notifierService.getConfig();\n      this.ready = new EventEmitter();\n      this.dismiss = new EventEmitter();\n      this.timerService = notifierTimerService;\n      this.animationService = notifierAnimationService;\n      this.renderer = renderer;\n      this.element = elementRef.nativeElement;\n      this.elementShift = 0;\n    }\n    /**\n     * Component after view init lifecycle hook, setts up the component and then emits the ready event\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this.setup();\n      this.elementHeight = this.element.offsetHeight;\n      this.elementWidth = this.element.offsetWidth;\n      this.ready.emit(this);\n    }\n    /**\n     * Get the notifier config\n     *\n     * @return {?} Notifier configuration\n     */\n\n\n    getConfig() {\n      return this.config;\n    }\n    /**\n     * Get notification element height (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n\n\n    getHeight() {\n      return this.elementHeight;\n    }\n    /**\n     * Get notification element width (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n\n\n    getWidth() {\n      return this.elementWidth;\n    }\n    /**\n     * Get notification shift offset (in px)\n     *\n     * @return {?} Notification element shift offset (in px)\n     */\n\n\n    getShift() {\n      return this.elementShift;\n    }\n    /**\n     * Show (animate in) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n\n\n    show() {\n      return new Promise((resolve, reject) => {\n        // Are animations enabled?\n        if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n          // Get animation data\n          const\n          /** @type {?} */\n          animationData = this.animationService.getAnimationData('show', this.notification); // Set initial styles (styles before animation), prevents quick flicker when animation starts\n\n          const\n          /** @type {?} */\n          animatedProperties = Object.keys(animationData.keyframes[0]);\n\n          for (let\n          /** @type {?} */\n          i = animatedProperties.length - 1; i >= 0; i--) {\n            this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n          } // Animate notification in\n\n\n          this.renderer.setStyle(this.element, 'visibility', 'visible');\n          const\n          /** @type {?} */\n          animation = this.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish = () => {\n            this.startAutoHideTimer();\n            resolve(); // Done\n          };\n        } else {\n          // Show notification\n          this.renderer.setStyle(this.element, 'visibility', 'visible');\n          this.startAutoHideTimer();\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Hide (animate out) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n\n\n    hide() {\n      return new Promise((resolve, reject) => {\n        this.stopAutoHideTimer(); // Are animations enabled?\n\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n          const\n          /** @type {?} */\n          animationData = this.animationService.getAnimationData('hide', this.notification);\n          const\n          /** @type {?} */\n          animation = this.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish = () => {\n            resolve(); // Done\n          };\n        } else {\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Shift (move) this notification\n     *\n     * @param {?} distance         Distance to shift (in px)\n     * @param {?} shiftToMakePlace Flag, defining in which direction to shift\n     * @return {?} Promise, resolved when done\n     */\n\n\n    shift(distance, shiftToMakePlace) {\n      return new Promise((resolve, reject) => {\n        // Calculate new position (position after the shift)\n        let\n        /** @type {?} */\n        newElementShift;\n\n        if (this.config.position.vertical.position === 'top' && shiftToMakePlace || this.config.position.vertical.position === 'bottom' && !shiftToMakePlace) {\n          newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n        } else {\n          newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n        }\n\n        const\n        /** @type {?} */\n        horizontalPosition = this.config.position.horizontal.position === 'middle' ? '-50%' : '0'; // Are animations enabled?\n\n        if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n          const\n          /** @type {?} */\n          animationData = {\n            // TODO: Extract into animation service\n            keyframes: [{\n              transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`\n            }, {\n              transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`\n            }],\n            options: {\n              duration: this.config.animations.shift.speed,\n              easing: this.config.animations.shift.easing,\n              fill: 'forwards'\n            }\n          };\n          this.elementShift = newElementShift;\n          const\n          /** @type {?} */\n          animation = this.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish = () => {\n            resolve(); // Done\n          };\n        } else {\n          this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n          this.elementShift = newElementShift;\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Handle click on dismiss button\n     * @return {?}\n     */\n\n\n    onClickDismiss() {\n      this.dismiss.emit(this.notification.id);\n    }\n    /**\n     * Handle mouseover over notification area\n     * @return {?}\n     */\n\n\n    onNotificationMouseover() {\n      if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n        this.pauseAutoHideTimer();\n      } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n        this.stopAutoHideTimer();\n      }\n    }\n    /**\n     * Handle mouseout from notification area\n     * @return {?}\n     */\n\n\n    onNotificationMouseout() {\n      if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n        this.continueAutoHideTimer();\n      } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n        this.startAutoHideTimer();\n      }\n    }\n    /**\n     * Handle click on notification area\n     * @return {?}\n     */\n\n\n    onNotificationClick() {\n      if (this.config.behaviour.onClick === 'hide') {\n        this.onClickDismiss();\n      }\n    }\n    /**\n     * Start the auto hide timer (if enabled)\n     * @return {?}\n     */\n\n\n    startAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.start(this.config.behaviour.autoHide).then(() => {\n          this.onClickDismiss();\n        });\n      }\n    }\n    /**\n     * Pause the auto hide timer (if enabled)\n     * @return {?}\n     */\n\n\n    pauseAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.pause();\n      }\n    }\n    /**\n     * Continue the auto hide timer (if enabled)\n     * @return {?}\n     */\n\n\n    continueAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.continue();\n      }\n    }\n    /**\n     * Stop the auto hide timer (if enabled)\n     * @return {?}\n     */\n\n\n    stopAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.stop();\n      }\n    }\n    /**\n     * Initial notification setup\n     * @return {?}\n     */\n\n\n    setup() {\n      // Set start position (initially the exact same for every new notification)\n      if (this.config.position.horizontal.position === 'left') {\n        this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n      } else if (this.config.position.horizontal.position === 'right') {\n        this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n      } else {\n        this.renderer.setStyle(this.element, 'left', '50%'); // Let's get the GPU handle some work as well (#perfmatters)\n\n        this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n      }\n\n      if (this.config.position.vertical.position === 'top') {\n        this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n      } else {\n        this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n      } // Add classes (responsible for visual design)\n\n\n      this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n      this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n    }\n\n  }\n\n  NotifierNotificationComponent.ɵfac = function NotifierNotificationComponent_Factory(t) {\n    return new (t || NotifierNotificationComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NotifierService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NotifierTimerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NotifierAnimationService));\n  };\n\n  NotifierNotificationComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NotifierNotificationComponent,\n    selectors: [[\"notifier-notification\"]],\n    hostAttrs: [1, \"notifier__notification\"],\n    hostBindings: function NotifierNotificationComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_click_HostBindingHandler() {\n          return ctx.onNotificationClick();\n        })(\"mouseout\", function NotifierNotificationComponent_mouseout_HostBindingHandler() {\n          return ctx.onNotificationMouseout();\n        })(\"mouseover\", function NotifierNotificationComponent_mouseover_HostBindingHandler() {\n          return ctx.onNotificationMouseover();\n        });\n      }\n    },\n    inputs: {\n      notification: \"notification\"\n    },\n    outputs: {\n      ready: \"ready\",\n      dismiss: \"dismiss\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([NotifierTimerService])],\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"notifier__notification-message\"], [\"class\", \"notifier__notification-button\", \"title\", \"dismiss\", \"type\", \"button\", 3, \"click\", 4, \"ngIf\"], [\"title\", \"dismiss\", \"type\", \"button\", 1, \"notifier__notification-button\", 3, \"click\"], [\"height\", \"20\", \"viewBox\", \"0 0 24 24\", \"width\", \"20\", 1, \"notifier__notification-button-icon\"], [\"d\", \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"]],\n    template: function NotifierNotificationComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"p\", 0);\n        ɵngcc0.ɵɵtext(1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(2, NotifierNotificationComponent_button_2_Template, 3, 0, \"button\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate(ctx.notification.message);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.config.behaviour.showDismissButton);\n      }\n    },\n    directives: [ɵngcc4.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NotifierNotificationComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction NotifierNotificationComponent_tsickle_Closure_declarations() {\n  /**\n   * Input: Notification object, contains all details necessary to construct the notification\n   * @type {?}\n   */\n  NotifierNotificationComponent.prototype.notification;\n  /**\n   * Output: Ready event, handles the initialization success by emitting a reference to this notification component\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.ready;\n  /**\n   * Output: Dismiss event, handles the click on the dismiss button by emitting the notification ID of this notification component\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.dismiss;\n  /**\n   * Notifier configuration\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.config;\n  /**\n   * Notifier timer service\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.timerService;\n  /**\n   * Notifier animation service\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.animationService;\n  /**\n   * Angular renderer, used to preserve the overall DOM abstraction & independence\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.renderer;\n  /**\n   * Native element reference, used for manipulating DOM properties\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.element;\n  /**\n   * Current notification height, calculated and cached here (#perfmatters)\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.elementHeight;\n  /**\n   * Current notification width, calculated and cached here (#perfmatters)\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.elementWidth;\n  /**\n   * Current notification shift, calculated and cached here (#perfmatters)\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.elementShift;\n} //# sourceMappingURL=notifier-notification.component.js.map","map":null,"metadata":{},"sourceType":"module"}