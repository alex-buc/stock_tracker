{"ast":null,"code":"/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nexport let NotifierQueueService = /*#__PURE__*/(() => {\n  class NotifierQueueService {\n    /**\n     * Constructor\n     */\n    constructor() {\n      this.actionStream = new Subject();\n      this.actionQueue = [];\n      this.isActionInProgress = false;\n    }\n    /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param {?} action Action object\n     * @return {?}\n     */\n\n\n    push(action) {\n      this.actionQueue.push(action);\n      this.tryToRunNextAction();\n    }\n    /**\n     * Continue with the next action (called when the current action is finished)\n     * @return {?}\n     */\n\n\n    continue() {\n      this.isActionInProgress = false;\n      this.tryToRunNextAction();\n    }\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     * @return {?}\n     */\n\n\n    tryToRunNextAction() {\n      if (this.isActionInProgress || this.actionQueue.length === 0) {\n        return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n      }\n\n      this.isActionInProgress = true;\n      this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n    }\n\n  }\n\n  NotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) {\n    return new (t || NotifierQueueService)();\n  };\n\n  NotifierQueueService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NotifierQueueService,\n    factory: NotifierQueueService.ɵfac\n  });\n  /** @nocollapse */\n\n  return NotifierQueueService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction NotifierQueueService_tsickle_Closure_declarations() {\n  /**\n   * Stream of actions, subscribable from outside\n   * @type {?}\n   */\n  NotifierQueueService.prototype.actionStream;\n  /**\n   * Queue of actions\n   * @type {?}\n   */\n\n  NotifierQueueService.prototype.actionQueue;\n  /**\n   * Flag, true if some action is currently in progress\n   * @type {?}\n   */\n\n  NotifierQueueService.prototype.isActionInProgress;\n} //# sourceMappingURL=notifier-queue.service.js.map","map":null,"metadata":{},"sourceType":"module"}