{"ast":null,"code":"/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component } from '@angular/core';\nimport { NotifierNotification } from './../models/notifier-notification.model';\nimport { NotifierQueueService } from './../services/notifier-queue.service';\nimport { NotifierService } from './../services/notifier.service';\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from './../services/notifier-queue.service';\nimport * as ɵngcc2 from './../services/notifier.service';\n\nfunction NotifierContainerComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 1)(1, \"notifier-notification\", 2);\n    ɵngcc0.ɵɵlistener(\"dismiss\", function NotifierContainerComponent_li_1_Template_notifier_notification_dismiss_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.onNotificationDismiss($event);\n    })(\"ready\", function NotifierContainerComponent_li_1_Template_notifier_notification_ready_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.onNotificationReady($event);\n    });\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const notification_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"notification\", notification_r1);\n  }\n}\n\nexport let NotifierContainerComponent = /*#__PURE__*/(() => {\n  class NotifierContainerComponent {\n    /**\n     * Constructor\n     *\n     * @param {?} changeDetector       Change detector, used for manually triggering change detection runs\n     * @param {?} notifierQueueService Notifier queue service\n     * @param {?} notifierService      Notifier service\n     */\n    constructor(changeDetector, notifierQueueService, notifierService) {\n      this.changeDetector = changeDetector;\n      this.queueService = notifierQueueService;\n      this.config = notifierService.getConfig();\n      this.notifications = [];\n    }\n    /**\n     * Component initialization lifecycle hook, connects this component to the action queue, and then handles incoming actions\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.queueServiceSubscription = this.queueService.actionStream.subscribe(action => {\n        this.handleAction(action).then(() => {\n          this.queueService.continue();\n        });\n      });\n    }\n    /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.queueServiceSubscription) {\n        this.queueServiceSubscription.unsubscribe();\n      }\n    }\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param {?} index        Index\n     * @param {?} notification Notifier notification\n     * @return {?} Notification ID as the unique identnfier\n     */\n\n\n    identifyNotification(index, notification) {\n      return notification.id;\n    }\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param {?} notificationId ID of the notification to dismiss\n     * @return {?}\n     */\n\n\n    onNotificationDismiss(notificationId) {\n      this.queueService.push({\n        payload: notificationId,\n        type: 'HIDE'\n      });\n    }\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param {?} notificationComponent Notification component reference\n     * @return {?}\n     */\n\n\n    onNotificationReady(notificationComponent) {\n      let\n      /** @type {?} */\n      currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n\n      currentNotification.component = notificationComponent; // Save the new omponent reference\n\n      this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n\n    handleAction(action) {\n      switch (action.type) {\n        // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n        case 'SHOW':\n          return this.handleShowAction(action);\n\n        case 'HIDE':\n          return this.handleHideAction(action);\n\n        case 'HIDE_OLDEST':\n          return this.handleHideOldestAction(action);\n\n        case 'HIDE_NEWEST':\n          return this.handleHideNewestAction(action);\n\n        case 'HIDE_ALL':\n          return this.handleHideAllAction(action);\n\n        default:\n          return new Promise((resolve, reject) => {\n            resolve(); // Ignore unknown action types\n          });\n      }\n    }\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n\n    handleShowAction(action) {\n      return new Promise((resolve, reject) => {\n        this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n\n        this.addNotificationToList(new NotifierNotification(action.payload));\n      });\n    }\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param {?} notification New notification to show\n     * @return {?}\n     */\n\n\n    continueHandleShowAction(notification) {\n      // First (which means only one) notification in the list?\n      const\n      /** @type {?} */\n      numberOfNotifications = this.notifications.length;\n\n      if (numberOfNotifications === 1) {\n        notification.component.show().then(this.tempPromiseResolver); // Done\n      } else {\n        const\n        /** @type {?} */\n        implicitStackingLimit = 2; // Stacking enabled? (stacking value below 2 means stacking is disabled)\n\n        if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n          this.notifications[0].component.hide().then(() => {\n            this.removeNotificationFromList(this.notifications[0]);\n            notification.component.show().then(this.tempPromiseResolver); // Done\n          });\n        } else {\n          const\n          /** @type {?} */\n          stepPromises = []; // Are there now too many notifications?\n\n          if (numberOfNotifications > this.config.behaviour.stacking) {\n            const\n            /** @type {?} */\n            oldNotifications = this.notifications.slice(1, numberOfNotifications - 1); // Are animations enabled?\n\n            if (this.config.animations.enabled) {\n              // Is animation overlap enabled?\n              if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                stepPromises.push(this.notifications[0].component.hide());\n                setTimeout(() => {\n                  stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                }, this.config.animations.hide.speed - this.config.animations.overlap);\n                setTimeout(() => {\n                  stepPromises.push(notification.component.show());\n                }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n              } else {\n                stepPromises.push(new Promise((resolve, reject) => {\n                  this.notifications[0].component.hide().then(() => {\n                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                      notification.component.show().then(resolve);\n                    });\n                  });\n                }));\n              }\n            } else {\n              stepPromises.push(this.notifications[0].component.hide());\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              stepPromises.push(notification.component.show());\n            }\n          } else {\n            const\n            /** @type {?} */\n            oldNotifications = this.notifications.slice(0, numberOfNotifications - 1); // Are animations enabled?\n\n            if (this.config.animations.enabled) {\n              // Is animation overlap enabled?\n              if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                setTimeout(() => {\n                  stepPromises.push(notification.component.show());\n                }, this.config.animations.shift.speed - this.config.animations.overlap);\n              } else {\n                stepPromises.push(new Promise((resolve, reject) => {\n                  this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                    notification.component.show().then(resolve);\n                  });\n                }));\n              }\n            } else {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              stepPromises.push(notification.component.show());\n            }\n          }\n\n          Promise.all(stepPromises).then(() => {\n            if (numberOfNotifications > this.config.behaviour.stacking) {\n              this.removeNotificationFromList(this.notifications[0]);\n            }\n\n            this.tempPromiseResolver();\n          }); // Done\n        }\n      }\n    }\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param {?} action Action object, payload contains the notification ID\n     * @return {?} Promise, resolved when done\n     */\n\n\n    handleHideAction(action) {\n      return new Promise((resolve, reject) => {\n        const\n        /** @type {?} */\n        stepPromises = []; // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n\n        const\n        /** @type {?} */\n        notification = this.findNotificationById(action.payload);\n\n        if (notification === undefined) {\n          resolve();\n          return;\n        } // Get older notifications\n\n\n        const\n        /** @type {?} */\n        notificationIndex = this.findNotificationIndexById(action.payload);\n\n        if (notificationIndex === undefined) {\n          resolve();\n          return;\n        }\n\n        const\n        /** @type {?} */\n        oldNotifications = this.notifications.slice(0, notificationIndex); // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n\n        if (oldNotifications.length > 0) {\n          // Are animations enabled?\n          if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(notification.component.hide());\n              setTimeout(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n              }, this.config.animations.hide.speed - this.config.animations.overlap);\n            } else {\n              notification.component.hide().then(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n              });\n            }\n          } else {\n            stepPromises.push(notification.component.hide());\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n          }\n        } else {\n          stepPromises.push(notification.component.hide());\n        } // Wait until both hiding and shifting is done, then remove the notification from the list\n\n\n        Promise.all(stepPromises).then(() => {\n          this.removeNotificationFromList(notification);\n          resolve(); // Done\n        });\n      });\n    }\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n\n    handleHideOldestAction(action) {\n      // Are there any notifications? (prevent accidential errors)\n      if (this.notifications.length === 0) {\n        return new Promise((resolve, reject) => {\n          resolve();\n        }); // Done\n      } else {\n        action.payload = this.notifications[0].id;\n        return this.handleHideAction(action);\n      }\n    }\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n\n    handleHideNewestAction(action) {\n      // Are there any notifications? (prevent accidential errors)\n      if (this.notifications.length === 0) {\n        return new Promise((resolve, reject) => {\n          resolve();\n        }); // Done\n      } else {\n        action.payload = this.notifications[this.notifications.length - 1].id;\n        return this.handleHideAction(action);\n      }\n    }\n    /**\n     * Hide all notifications at once\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n\n    handleHideAllAction(action) {\n      return new Promise((resolve, reject) => {\n        // Are there any notifications? (prevent accidential errors)\n        const\n        /** @type {?} */\n        numberOfNotifications = this.notifications.length;\n\n        if (numberOfNotifications === 0) {\n          resolve(); // Done\n\n          return;\n        } // Are animations enabled?\n\n\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false && this.config.animations.hide.offset > 0) {\n          for (let\n          /** @type {?} */\n          i = numberOfNotifications - 1; i >= 0; i--) {\n            const\n            /** @type {?} */\n            animationOffset = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n            setTimeout(() => {\n              this.notifications[i].component.hide().then(() => {\n                // Are we done here, was this the last notification to be hidden?\n                if (this.config.position.vertical.position === 'top' && i === 0 || this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1) {\n                  this.removeAllNotificationsFromList();\n                  resolve(); // Done\n                }\n              });\n            }, this.config.animations.hide.offset * animationOffset);\n          }\n        } else {\n          let\n          /** @type {?} */\n          stepPromises = [];\n\n          for (let\n          /** @type {?} */\n          i = numberOfNotifications - 1; i >= 0; i--) {\n            stepPromises.push(this.notifications[i].component.hide());\n          }\n\n          Promise.all(stepPromises).then(() => {\n            this.removeAllNotificationsFromList();\n            resolve(); // Done\n          });\n        }\n      });\n    }\n    /**\n     * Shift multiple notifications at once\n     *\n     * @param {?} notifications List containing the notifications to be shifted\n     * @param {?} distance      Distance to shift (in px)\n     * @param {?} toMakePlace   Flag, defining in which direciton to shift\n     * @return {?} Promise, resolved when done\n     */\n\n\n    shiftNotifications(notifications, distance, toMakePlace) {\n      return new Promise((resolve, reject) => {\n        // Are there any notifications to shift?\n        if (notifications.length === 0) {\n          resolve();\n          return;\n        }\n\n        let\n        /** @type {?} */\n        notificationPromises = [];\n\n        for (let\n        /** @type {?} */\n        i = notifications.length - 1; i >= 0; i--) {\n          notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n        }\n\n        Promise.all(notificationPromises).then(resolve); // Done\n      });\n    }\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param {?} notification Notification to add to the list of notifications\n     * @return {?}\n     */\n\n\n    addNotificationToList(notification) {\n      this.notifications.push(notification);\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param {?} notification Notification to be removed from the list of notifications\n     * @return {?}\n     */\n\n\n    removeNotificationFromList(notification) {\n      this.notifications = this.notifications.filter(item => item.component !== notification.component);\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     * @return {?}\n     */\n\n\n    removeAllNotificationsFromList() {\n      this.notifications = [];\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param {?} notificationId Notification ID, used for finding notification\n     * @return {?} Notification, undefined if not found\n     */\n\n\n    findNotificationById(notificationId) {\n      return this.notifications.find(currentNotification => currentNotification.id === notificationId);\n    }\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param {?} notificationId Notification ID, used for finding a notification's index\n     * @return {?} Notification index, undefined if not found\n     */\n\n\n    findNotificationIndexById(notificationId) {\n      const\n      /** @type {?} */\n      notificationIndex = this.notifications.findIndex(currentNotification => currentNotification.id === notificationId);\n      return notificationIndex !== -1 ? notificationIndex : undefined;\n    }\n\n  }\n\n  NotifierContainerComponent.ɵfac = function NotifierContainerComponent_Factory(t) {\n    return new (t || NotifierContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NotifierQueueService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NotifierService));\n  };\n\n  NotifierContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NotifierContainerComponent,\n    selectors: [[\"notifier-container\"]],\n    hostAttrs: [1, \"notifier__container\"],\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"notifier__container-list\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"notifier__container-list\"], [3, \"notification\", \"dismiss\", \"ready\"]],\n    template: function NotifierContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\");\n        ɵngcc0.ɵɵtemplate(1, NotifierContainerComponent_li_1_Template, 2, 1, \"li\", 0);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.notifications)(\"ngForTrackBy\", ctx.identifyNotification);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return NotifierContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction NotifierContainerComponent_tsickle_Closure_declarations() {\n  /**\n   * List of currently somewhat active notifications\n   * @type {?}\n   */\n  NotifierContainerComponent.prototype.notifications;\n  /**\n   * Change detector\n   * @type {?}\n   */\n\n  NotifierContainerComponent.prototype.changeDetector;\n  /**\n   * Notifier queue service\n   * @type {?}\n   */\n\n  NotifierContainerComponent.prototype.queueService;\n  /**\n   * Notifier configuration\n   * @type {?}\n   */\n\n  NotifierContainerComponent.prototype.config;\n  /**\n   * Queue service observable subscription (saved for cleanup)\n   * @type {?}\n   */\n\n  NotifierContainerComponent.prototype.queueServiceSubscription;\n  /**\n   * Promise resolve function reference, temporarily used while the notification child component gets created\n   * @type {?}\n   */\n\n  NotifierContainerComponent.prototype.tempPromiseResolver;\n} //# sourceMappingURL=notifier-container.component.js.map","map":null,"metadata":{},"sourceType":"module"}