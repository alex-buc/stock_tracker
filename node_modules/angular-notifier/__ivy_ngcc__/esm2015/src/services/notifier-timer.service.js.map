{"version":3,"file":"notifier-timer.service.js","sources":["notifier-timer.service.ts"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C;AACG;AACsB;AACvB;AACuI;AAClB;;AAGvH,MAAM;AACN;AAEE;AAAmB;AAAQ;AAAoB,QAuBzC,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AACrB,QAAQ,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AAC3B;AACA;AAEE;AAED;AAAO;AACK;AAER;AAAQ,IAAF,KAAK,CAAC,QAAgB;AAAI,QAC7B,MAAM,CAAC,IAAI,OAAO,CAAY,CAAC,OAAmB,EAAE,MAAkB,EAAE,EAAE;AAClF;AACoC,YACxB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;AACtC;AAC0C,YAC9B,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC;AACjD,YAAY,IAAI,CAAC,QAAQ,EAAE,CAAC;AAC5B,SACS,CAAC,CAAC;AACX;AACA;AAEE;AAEF;AAAmB;AACnB,IADW,KAAK;AAAK,QACb,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACnC,QAAQ,IAAI,CAAC,SAAS,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC;AAC1D;AACA;AAEE;AAEF;AAAmB;AAAQ,IAAhB,QAAQ;AAAK,QAChB,IAAI,CAAC,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;AACxC,QAAQ,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE;AAC9C,YAAY,IAAI,CAAC,MAAM,EAAE,CAAC;AAC1B,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;AAC3B;AACA;AAEE;AAEF;AAAmB;AAClB,IADU,IAAI;AAAK,QACZ,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACnC,QAAQ,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AAC3B;AACA;AAEE;AAEF;AAAmB;AAAQ,IAAf,MAAM;AAAK,QACf,IAAI,CAAC,qBAAqB,EAAE,CAAC;AACrC;AACA;gDAlFC,UAAU;0IACR;AAAC;AAAmB;;;gDAGK;AAAC;AAG7B;AAEE;AAIC;AACY;AAAQ;AAEpB;AAAQ;AAGL;AAAiB;AAAQ;AAA8C;AAE7E;AAGK;AAEJ;AAAQ;AAEL;AAAQ;AAMO;AAAiB;AACpC;AAA0D;AAAE","sourcesContent":["import { Injectable } from '@angular/core';\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\n@Injectable()\nexport class NotifierTimerService {\n\n\t/**\n\t * Timestamp (in ms), created in the moment the timer starts\n\t */\n    private now: number;\n\n\t/**\n\t * Remaining time (in ms)\n\t */\n    private remaining: number;\n\n\t/**\n\t * Timeout ID, used for clearing the timeout later on\n\t */\n    private timerId: number;\n\n\t/**\n\t * Promise resolve function, eventually getting called once the timer finishes\n\t */\n    private finishPromiseResolver: () => void;\n\n\t/**\n\t * Constructor\n\t */\n    public constructor() {\n        this.now = 0;\n        this.remaining = 0;\n    }\n\n\t/**\n\t * Start (or resume) the timer\n\t *\n\t * @param   duration Timer duration, in ms\n\t * @returns          Promise, resolved once the timer finishes\n\t */\n    public start(duration: number): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            // For the first run ...\n            this.remaining = duration;\n\n            // Setup, then start the timer\n            this.finishPromiseResolver = resolve;\n            this.continue();\n\n        });\n    }\n\n\t/**\n\t * Pause the timer\n\t */\n    public pause(): void {\n        clearTimeout(this.timerId);\n        this.remaining -= new Date().getTime() - this.now;\n    }\n\n\t/**\n\t * Continue the timer\n\t */\n    public continue(): void {\n        this.now = new Date().getTime();\n        this.timerId = window.setTimeout(() => {\n            this.finish();\n        }, this.remaining);\n    }\n\n\t/**\n\t * Stop the timer\n\t */\n    public stop(): void {\n        clearTimeout(this.timerId);\n        this.remaining = 0;\n    }\n\n\t/**\n\t * Finish up the timeout by resolving the timer promise\n\t */\n    private finish(): void {\n        this.finishPromiseResolver();\n    }\n\n}\n"]}