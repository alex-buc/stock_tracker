{"version":3,"file":"notifier-container.component.js","sources":["notifier-container.component.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnDestroy, OnInit } from '@angular/core';\n\nimport { Subscription } from 'rxjs';\n\nimport { NotifierAction } from './../models/notifier-action.model';\nimport { NotifierConfig } from './../models/notifier-config.model';\nimport { NotifierNotification } from './../models/notifier-notification.model';\nimport { NotifierQueueService } from './../services/notifier-queue.service';\nimport { NotifierService } from './../services/notifier.service';\nimport { NotifierNotificationComponent } from './notifier-notification.component';\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n@Component({\n    changeDetection: ChangeDetectionStrategy.OnPush, // (#perfmatters)\n    host: {\n        class: 'notifier__container'\n    },\n    selector: 'notifier-container',\n    template: '<ul><li *ngFor=\"let notification of notifications; trackBy: identifyNotification;\" class=\"notifier__container-list\"><notifier-notification (dismiss)=\"onNotificationDismiss( $event )\" (ready)=\"onNotificationReady( $event )\" [notification]=\"notification\"></notifier-notification></ul>'\n})\nexport class NotifierContainerComponent implements OnDestroy, OnInit {\n\n\t/**\n\t * List of currently somewhat active notifications\n\t */\n    public notifications: Array<NotifierNotification>;\n\n\t/**\n\t * Change detector\n\t */\n    private readonly changeDetector: ChangeDetectorRef;\n\n\t/**\n\t * Notifier queue service\n\t */\n    private readonly queueService: NotifierQueueService;\n\n\t/**\n\t * Notifier configuration\n\t */\n    private readonly config: NotifierConfig;\n\n\t/**\n\t * Queue service observable subscription (saved for cleanup)\n\t */\n    private queueServiceSubscription: Subscription;\n\n\t/**\n\t * Promise resolve function reference, temporarily used while the notification child component gets created\n\t */\n    private tempPromiseResolver: () => void;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param changeDetector       Change detector, used for manually triggering change detection runs\n\t * @param notifierQueueService Notifier queue service\n\t * @param notifierService      Notifier service\n\t */\n    public constructor(changeDetector: ChangeDetectorRef, notifierQueueService: NotifierQueueService, notifierService: NotifierService) {\n        this.changeDetector = changeDetector;\n        this.queueService = notifierQueueService;\n        this.config = notifierService.getConfig();\n        this.notifications = [];\n    }\n\n\t/**\n\t * Component initialization lifecycle hook, connects this component to the action queue, and then handles incoming actions\n\t */\n    public ngOnInit(): void {\n        this.queueServiceSubscription = this.queueService.actionStream.subscribe((action: NotifierAction) => {\n            this.handleAction(action).then(() => {\n                this.queueService.continue();\n            });\n        });\n    }\n\n\t/**\n\t * Component destroyment lifecycle hook, cleans up the observable subsciption\n\t */\n    public ngOnDestroy(): void {\n        if (this.queueServiceSubscription) {\n            this.queueServiceSubscription.unsubscribe();\n        }\n    }\n\n\t/**\n\t * Notification identifier, used as the ngFor trackby function\n\t *\n\t * @param   index        Index\n\t * @param   notification Notifier notification\n\t * @returns Notification ID as the unique identnfier\n\t */\n    public identifyNotification(index: number, notification: NotifierNotification): string {\n        return notification.id;\n    }\n\n\t/**\n\t * Event handler, handles clicks on notification dismiss buttons\n\t *\n\t * @param notificationId ID of the notification to dismiss\n\t */\n    public onNotificationDismiss(notificationId: string): void {\n        this.queueService.push({\n            payload: notificationId,\n            type: 'HIDE'\n        });\n    }\n\n\t/**\n\t * Event handler, handles notification ready events\n\t *\n\t * @param notificationComponent Notification component reference\n\t */\n    public onNotificationReady(notificationComponent: NotifierNotificationComponent): void {\n        let currentNotification: NotifierNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n        currentNotification.component = notificationComponent; // Save the new omponent reference\n        this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n\n\t/**\n\t * Handle incoming actions by mapping action types to methods, and then running them\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleAction(action: NotifierAction): Promise<undefined> {\n        switch (action.type) { // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n            case 'SHOW':\n                return this.handleShowAction(action);\n            case 'HIDE':\n                return this.handleHideAction(action);\n            case 'HIDE_OLDEST':\n                return this.handleHideOldestAction(action);\n            case 'HIDE_NEWEST':\n                return this.handleHideNewestAction(action);\n            case 'HIDE_ALL':\n                return this.handleHideAllAction(action);\n            default:\n                return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                    resolve(); // Ignore unknown action types\n                });\n        }\n    }\n\n\t/**\n\t * Show a new notification\n\t *\n\t * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleShowAction(action: NotifierAction): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n            this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n            this.addNotificationToList(new NotifierNotification(action.payload));\n        });\n    }\n\n\t/**\n\t * Continue to show a new notification (after the notification components is initialized / created / rendered).\n\t *\n\t * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n\t * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n\t * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n\t * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n\t *\n\t * @param notification New notification to show\n\t */\n    private continueHandleShowAction(notification: NotifierNotification): void {\n\n        // First (which means only one) notification in the list?\n        const numberOfNotifications: number = this.notifications.length;\n        if (numberOfNotifications === 1) {\n            notification.component.show().then(this.tempPromiseResolver); // Done\n        } else {\n\n            const implicitStackingLimit: number = 2;\n\n            // Stacking enabled? (stacking value below 2 means stacking is disabled)\n            if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n                this.notifications[0].component.hide().then(() => {\n                    this.removeNotificationFromList(this.notifications[0]);\n                    notification.component.show().then(this.tempPromiseResolver); // Done\n                });\n            } else {\n\n                const stepPromises: Array<Promise<undefined>> = [];\n\n                // Are there now too many notifications?\n                if (numberOfNotifications > this.config.behaviour.stacking) {\n\n                    const oldNotifications: Array<NotifierNotification> = this.notifications.slice(1, numberOfNotifications - 1);\n\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.notifications[0].component.hide());\n                            setTimeout(() => {\n                                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            }, this.config.animations.hide.speed - this.config.animations.overlap);\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n                        } else {\n                            stepPromises.push(new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                                this.notifications[0].component.hide().then(() => {\n                                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                        notification.component.show().then(resolve);\n                                    });\n                                });\n                            }));\n                        }\n\n                    } else {\n                        stepPromises.push(this.notifications[0].component.hide());\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n\n                } else {\n\n                    const oldNotifications: Array<NotifierNotification> = this.notifications.slice(0, numberOfNotifications - 1);\n\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.shift.speed - this.config.animations.overlap);\n                        } else {\n                            stepPromises.push(new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                                this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                    notification.component.show().then(resolve);\n                                });\n                            }));\n                        }\n\n                    } else {\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n\n                }\n\n                Promise.all(stepPromises).then(() => {\n                    if (numberOfNotifications > this.config.behaviour.stacking) {\n                        this.removeNotificationFromList(this.notifications[0]);\n                    }\n                    this.tempPromiseResolver();\n                }); // Done\n\n            }\n\n        }\n\n    }\n\n\t/**\n\t * Hide an existing notification\n\t *\n\t * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n\t * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n\t * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n\t *\n\t * @param   action Action object, payload contains the notification ID\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideAction(action: NotifierAction): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            const stepPromises: Array<Promise<undefined>> = [];\n\n            // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n            const notification: NotifierNotification | undefined = this.findNotificationById(action.payload);\n            if (notification === undefined) {\n                resolve();\n                return;\n            }\n\n            // Get older notifications\n            const notificationIndex: number | undefined = this.findNotificationIndexById(action.payload);\n            if (notificationIndex === undefined) {\n                resolve();\n                return;\n            }\n            const oldNotifications: Array<NotifierNotification> = this.notifications.slice(0, notificationIndex);\n\n            // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n            if (oldNotifications.length > 0) {\n\n                // Are animations enabled?\n                if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n\n                    // Is animation overlap enabled?\n                    if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                        stepPromises.push(notification.component.hide());\n                        setTimeout(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        }, this.config.animations.hide.speed - this.config.animations.overlap);\n                    } else {\n                        notification.component.hide().then(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        });\n                    }\n                } else {\n                    stepPromises.push(notification.component.hide());\n                    stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                }\n\n            } else {\n\n                stepPromises.push(notification.component.hide());\n\n            }\n\n            // Wait until both hiding and shifting is done, then remove the notification from the list\n            Promise.all(stepPromises).then(() => {\n                this.removeNotificationFromList(notification);\n                resolve(); // Done\n            });\n\n        });\n\n    }\n\n\t/**\n\t * Hide the oldest notification (bridge to handleHideAction)\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideOldestAction(action: NotifierAction): Promise<undefined> {\n\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                resolve();\n            }); // Done\n        } else {\n            action.payload = this.notifications[0].id;\n            return this.handleHideAction(action);\n        }\n\n    }\n\n\t/**\n\t * Hide the newest notification (bridge to handleHideAction)\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideNewestAction(action: NotifierAction): Promise<undefined> {\n\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                resolve();\n            }); // Done\n        } else {\n            action.payload = this.notifications[this.notifications.length - 1].id;\n            return this.handleHideAction(action);\n        }\n\n    }\n\n\t/**\n\t * Hide all notifications at once\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideAllAction(action: NotifierAction): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            // Are there any notifications? (prevent accidential errors)\n            const numberOfNotifications: number = this.notifications.length;\n            if (numberOfNotifications === 0) {\n                resolve(); // Done\n                return;\n            }\n\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false &&\n                this.config.animations.hide.offset > 0) {\n\n                for (let i: number = numberOfNotifications - 1; i >= 0; i--) {\n                    const animationOffset: number = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n                    setTimeout(() => {\n                        this.notifications[i].component.hide().then(() => {\n\n                            // Are we done here, was this the last notification to be hidden?\n                            if ((this.config.position.vertical.position === 'top' && i === 0) ||\n                                (this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1)) {\n                                this.removeAllNotificationsFromList();\n                                resolve(); // Done\n                            }\n\n                        });\n                    }, this.config.animations.hide.offset * animationOffset);\n                }\n\n            } else {\n\n                let stepPromises: Array<Promise<undefined>> = [];\n                for (let i: number = numberOfNotifications - 1; i >= 0; i--) {\n                    stepPromises.push(this.notifications[i].component.hide());\n                }\n                Promise.all(stepPromises).then(() => {\n                    this.removeAllNotificationsFromList();\n                    resolve(); // Done\n                });\n\n            }\n\n        });\n    }\n\n\t/**\n\t * Shift multiple notifications at once\n\t *\n\t * @param   notifications List containing the notifications to be shifted\n\t * @param   distance      Distance to shift (in px)\n\t * @param   toMakePlace   Flag, defining in which direciton to shift\n\t * @returns Promise, resolved when done\n\t */\n    private shiftNotifications(notifications: Array<NotifierNotification>, distance: number, toMakePlace: boolean): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            // Are there any notifications to shift?\n            if (notifications.length === 0) {\n                resolve();\n                return;\n            }\n\n            let notificationPromises: Array<Promise<undefined>> = [];\n            for (let i: number = notifications.length - 1; i >= 0; i--) {\n                notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n            }\n            Promise.all(notificationPromises).then(resolve); // Done\n\n        });\n    }\n\n\t/**\n\t * Add a new notification to the list of notifications (triggers change detection)\n\t *\n\t * @param notification Notification to add to the list of notifications\n\t */\n    private addNotificationToList(notification: NotifierNotification): void {\n        this.notifications.push(notification);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n\n\t/**\n\t * Remove an existing notification from the list of notifications (triggers change detection)\n\t *\n\t * @param notification Notification to be removed from the list of notifications\n\t */\n    private removeNotificationFromList(notification: NotifierNotification): void {\n        this.notifications =\n            this.notifications.filter((item: NotifierNotification) => item.component !== notification.component);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n\n\t/**\n\t * Remove all notifications from the list (triggers change detection)\n\t */\n    private removeAllNotificationsFromList(): void {\n        this.notifications = [];\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n\n\t/**\n\t * Helper: Find a notification in the notification list by a given notification ID\n\t *\n\t * @param   notificationId Notification ID, used for finding notification\n\t * @returns Notification, undefined if not found\n\t */\n    private findNotificationById(notificationId: string): NotifierNotification | undefined {\n        return this.notifications.find((currentNotification: NotifierNotification) => currentNotification.id === notificationId);\n    }\n\n\t/**\n\t * Helper: Find a notification's index by a given notification ID\n\t *\n\t * @param   notificationId Notification ID, used for finding a notification's index\n\t * @returns Notification index, undefined if not found\n\t */\n    private findNotificationIndexById(notificationId: string): number | undefined {\n        const notificationIndex: number =\n            this.notifications.findIndex((currentNotification: NotifierNotification) => currentNotification.id === notificationId);\n        return (notificationIndex !== -1 ? notificationIndex : undefined);\n    }\n\n}\n"]}